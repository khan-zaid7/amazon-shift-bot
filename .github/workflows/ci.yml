# .github/workflows/ci.yml

#name of the workflow, will be shown on github actions
name: Node.js CI (continuous integration)

# defining when should a workflow run
    # the keyword 'on' to configure the trigger/specific events to run the workflow 
on:
    # 'push' - specific event that runs workflow when 'push' is triggerd
    push:
        # we can use 'branches'/'ignore-branches' to filter out tiggers on specific branch
        branches: ["master"]
    # 'pull_request' - specific event that runs workflow when 'pull_request' is triggerd
    pull_request:
        # we can use 'branches'/'ignore-branches' to filter out tiggers on specific branch
        branches: ["master"]

# 'job' - is a set of instructs which tell a machine to perform tasks
# every 'job' - runs a fresh virutal-machine called 'runner'

# jobs - which defines all the jobs in this workflow
jobs: 
    # Run the tests on every PR and PUSH
    test:
      name: Run Tests
      runs-on: ubuntu-latest

      # ***BEST PRACTICE***
        # github actions feature, run tests on different version of node to check its compatabilty
        # runs this job multiple times in parallel, with node version defined in node-version array 
      strategy:
        matrix: 
          node-version: [18.x, 20.x]

      steps:
        - name: Checkout repository
          uses: actions/checkout@v4
        
        - name: Setup Node.js ${{ matrix.node-version }}
          uses: actions/setup-node@v4
          with: 
            node-version: ${{ matrix.node-version }}
            cache: npm 
        - name: Install dependencies 
          run: npm ci

        - name: Run tests 
          run: npm test -- --coverage --passWithNoTests

      
    # unique id for a job 'build'
    build-and-push:
        # name of job : Build and Test
        name: Build and Push to GHCR
        # OS to run the job on
        runs-on: ubuntu-latest

        # dependencies and conditions on this job
        # making sure that the tests job ran with 100% success.
        needs: test
        # making sure that this build runs only on merge/push on master branch never on pull_requests
        if: github.ref == 'refs/heads/master' && github.event_name == 'push'

        # grant permission for job to write to the 
        # we are giving this job write package permissions
        permissions:
          contents: read
          packages: write 
        

        steps:
          
          # copy the code to the runner instance using checkout actions
          - name: Checkout repository
            uses: actions/checkout@v4
          
          # Setup actions to install advanced docker builder enginer 
          - name: Setup docker buildx
            uses: docker/setup-buildx-action@v3
          
          
          # this action handles the login to the container registery
          - name: Login to github container registery
            uses: docker/login-action@v3
            with: 
                # specifies that we are logining into github container registery
                registry: ghcr.io
                # A build-in github variable to use the person name who triggerd the action 
                username: ${{github.actor}}
                # Securly injects, the personal access token that I added earlier
                password: ${{secrets.GH_PAT}}
          
          # This actions creates smart tags for the Docker image
              # - For push to the main branch, it will create a tag 'main'
              # - If you push a git tag like (version 1.1.0), it will create a docker tag called `1.1.0`
              # - This saves us from manually configuring tags
          - name: Extract metadata (Tags, Labels) for Docker 
            id: meta
            uses: docker/metadata-action@v5
            # it tells the actions the name of the image we want to create, using format `gchr.io/your-username/your-repo-name`.
            with: ghcr.io/${{github.repository}}
            
          # This is the main event. It combines the docker build and docker push commands into one step. 
          - name: Build and push docker image 
            uses: docker/build-push-action@v5
            with: 
              # Look for the Dockerfile in the current directory
              context: . 
              # Tells the action to push the build to the container registery
              push: true
              # uses the smart tags, lables generated by meta step.
              tags: ${{steps.meta.outputs.tags}}
              labels: ${{steps.meta.outputs.labels}}
              # configure docker's build cache to be stored on github actions own infrastructure, spedding future builds 
              cache-from: type=gha
              cache-to: type=gha, mode=max```

        

        
