# .github/workflows/ci.yml

#name of the workflow, will be shown on github actions
name: Node.js CI (continuous integration)

# defining when should a workflow run
    # the keyword 'on' to configure the trigger/specific events to run the workflow 
on:
    # 'push' - specific event that runs workflow when 'push' is triggerd
    push:
        # we can use 'branches'/'ignore-branches' to filter out tiggers on specific branch
        branches: ["master"]
    # 'pull_request' - specific event that runs workflow when 'pull_request' is triggerd
    pull_request:
        # we can use 'branches'/'ignore-branches' to filter out tiggers on specific branch
        branches: ["master"]

# 'job' - is a set of instructs which tell a machine to perform tasks
# every 'job' - runs a fresh virutal-machine called 'runner'

# jobs - which defines all the jobs in this workflow
jobs: 
    # unique id for a job 'build-and-test'
    build-and-test:
        # name of job : Build and Test
        name: Build and Test
        # OS to run the job on
        runs-on: ubuntu-latest

        # ***BEST PRACTICE***
        # github actions feature, run tests on different version of node to check its compatabilty
        # runs this job multiple times in parallel, with node version defined in node-version array 
        strategy:
            matrix:
                node-version: [18.x, 20.x]

        # list of steps to execute on the fresh virtual matchine for this job
        # steps can either be:
            # 'run' (which runs on the shell of virutal machine)
            # 'uses' (which use pre-defined github actions)
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

        # dependencies and conditions on this job
        # making sure that the tests job ran with 100% success.
        needs: test

            - name: Install dependencies
              #install npm clean-install with strict versions defined in the package.json file
              run: npm ci 
            
            - name: Run Tests
              # run the npm test with a code coverage report (to see how much percentage of code is tested)
              # (--) prevents npm from running as a flag, stating its for the underlying script (jest)
              run: npm test -- --coverage --passWithNoTests

        steps:
          
          # copy the code to the runner instance using checkout actions
          - name: Checkout repository
            uses: actions/checkout@v4

          # Check if its a push to main branch
          - name: Check if running on master branch
            id: check_main
            if: github.ref != 'refs/heads/master' || github.event_name != 'push'
            run: echo "Skipping build and push for non-master branch" 
          
          # Setup actions to install advanced docker builder enginer 
          - name: Setup docker buildx
            if: success() && steps.check_main.conclusion == 'skipped'
            uses: docker/setup-buildx-action@v3
          
          
          # this action handles the login to the container registery
          - name: Login to github container registery
            if: success() && steps.check_main.conclusion == 'skipped'
            uses: docker/login-action@v3
            with: 
                # specifies that we are logining into github container registery
                registry: ghcr.io
                # A build-in github variable to use the person name who triggerd the action 
                username: ${{github.actor}}
                # Securly injects, the personal access token that I added earlier
                password: ${{secrets.GH_PAT}}
          
          # This actions creates smart tags for the Docker image
              # - For push to the main branch, it will create a tag 'main'
              # - If you push a git tag like (version 1.1.0), it will create a docker tag called `1.1.0`
              # - This saves us from manually configuring tags
          - name: Extract metadata (Tags, Labels) for Docker 
            if: success() && steps.check_main.conclusion == 'skipped'
            id: meta
            uses: docker/metadata-action@v5
            # it tells the actions the name of the image we want to create, using format `gchr.io/your-username/your-repo-name`.
            with: 
              images: ghcr.io/${{github.repository}}
            
          # This is the main event. It combines the docker build and docker push commands into one step. 
          - name: Build and push docker image 
            if: success() && steps.check_main.conclusion == 'skipped'
            uses: docker/build-push-action@v5
            with: 
              # Look for the Dockerfile in the current directory
              context: . 
              # Tells the action to push the build to the container registery
              push: true
              # uses the smart tags, lables generated by meta step.
              tags: ${{steps.meta.outputs.tags}}
              labels: ${{steps.meta.outputs.labels}}
              # configure docker's build cache to be stored on github actions own infrastructure, spedding future builds 
              cache-from: type=gha
              cache-to: type=gha, mode=max```

        

